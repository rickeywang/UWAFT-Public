#pragma config(Sensor, S1,     pet,                 sensorTouch)
#pragma config(Sensor, S2,     sonar,               sensorSONAR)
#pragma config(Sensor, S3,     feed,                sensorCOLORFULL)
#pragma config(Motor,  motorA,          leftM,         tmotorNormal, PIDControl, reversed, encoder)
#pragma config(Motor,  motorB,          rightM,        tmotorNormal, PIDControl, encoder)
#pragma config(Motor,  motorC,          headM,         tmotorNormal, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(NXT)

// Function and task prototypes
void checkBTLinkConnected();
void feedback(char type, char one, char two);
void movelegs(int leftMagitude, int rightMagitude, int time);
void movehead(int headangle);
//void movehead(int angleFromFlat, int wobbleAngle);
void die(string diereason);
void funeral();

task lifeSupport();
task randomMovement();
task interactions();

//Global variables
  //Hunger Index
  int hunger=50;
  //Happiness Index
  int happy=50;
  //Death
  bool death=false;
  string death_reason;
  //Head positions
  const int HEAD_NORMAL=60, HEAD_DEAD=200;
  //Reverse
  bool reverse=true;

task main()
{
  //Housekeeping
  	// Test Ability to Turn Bluetooth On or Off
	  checkBTLinkConnected();
		// Initialize Bluecore to "raw data" mode. This will be automatically reset when application terminates
		setBluetoothRawDataMode();
		while (!bBTRawMode)
		{
			// Wait for Bluecore to enter raw data mode
			wait1Msec(1);
		}
		eraseDisplay();
		bNxtLCDStatusDisplay = true; // Enable top status line display
		nMotorEncoder[headM] = 0;  //clear the LEGO encoders
		srand(nSysTime); //random seed based on system up time
		//Clears the timers
		ClearTimer(T2); //T2 is for feedback and TTS
		ClearTimer(T3); //T3 is for timeouts
		ClearTimer(T4); //T4 is for lifesupport


  //ACTUAL MAIN TASK
	hogCPU();
  StartTask(lifeSupport);
  StartTask(randomMovement);
  StartTask(interactions);
  releaseCPU();

	while (true)
	{
	  wait1Msec(300); // Allow for a short wait, freeing up the CPU for other tasks. And To reduce the screen flicker
    nxtDisplayCenteredTextLine(1, "Main Task Running!"); // Display that Main is running.

    if (time1[T3] > 3200){
      reverse = false;
      nxtDisplayString(4, "No reverse "+time1[T3]);
    } else if (time1[T3] > 8000){
      reverse = true;
      nxtDisplayString(3, "Revers allowed");
    }

    if(death){
      StopTask(lifeSupport);
      StopTask(randomMovement);
      StopTask(interactions);
      funeral();
      break;
    }
	}

	  return;
}

task lifeSupport()
{
  while(true)
  {
    wait1Msec(300); // Allow for a short wait, freeing up the CPU for other tasks.

    hogCPU(); //Nothing else happens when lifeSupport is run
    nxtDisplayCenteredTextLine(2, "Life Support Online");

    int depreciateTime = time1[T4];
    //T4 is the timer for hunger and happiness consumption. Every 10 seconds we deduct 2 food points and 5 happiness points.
    if(depreciateTime>10000){
      hunger -= 200;
      happy -= 500;
      ClearTimer(T4);
    }

    //Check hunger
    if(hunger<0){//dies
      die("Starvation");
    } else if(hunger>200){ //Stomach Limit
      die("Overweight");
    } else if(hunger < 10 && hunger > 6){
       feedback('S','0','5');
       wait1Msec(100);
       feedback('V','1','5');
       hunger = 6;
    }

    //Check mental health
    if(happy<-20)  die("Depression");

    //Check ultrasonic sonar dist
    const int leftMREV=-100, rightMREV=-100, timeREV=100;

    //Timer T3 for ultrasonic timeout, T2 for bluetooth messaging space
    ClearTimer(T2);
    if(reverse) ClearTimer(T3);
	  while(SensorValue[sonar] < 30 && reverse && !death)
    {
     movelegs(leftMREV, rightMREV, timeREV);
     nxtDisplayString(3, "Reversing "+time1[T3]);
     if(time1[T2] > 500){
       switch(random(5))
		    {
	      case 1:   feedback('S','0','7');  break;
	      case 2:   feedback('S','1','2'); break;
	      case 3:   feedback('S','1','3'); break;
		    }
        wait1Msec(100);
        ClearTimer(T2);
     }
     if(time1[T3] > 1000 && random(10)==0){
       feedback('S','1','1');
       wait1Msec(50);
     }
    }
    releaseCPU();
  }

  return;
}

task randomMovement()
{
  while(true && !death)
  {
    wait1Msec(220 + random(1000)); // Allow for a random short wait, freeing up the CPU for other tasks.
    nxtDisplayCenteredTextLine(3, "Random Online");
	  int leftM=random(100), rightM=random(100);
	  int headang=random(70), time=random(1000);
	  movehead(headang);
	  movelegs(leftM, rightM, time);
  }
  return;
}

task interactions(){
  while(true)
  {
    wait1Msec(200);  // Allow for a short wait, freeing up the CPU for other tasks.

    //Check for petting - add happiness index
	    if(SensorValue(pet) == 1)    // While the Pet Touch Sensor being pressed
	    {
	      happy += 10;
	      int actID=random(7); //Based on chance, it will say certain things
	      switch(actID)
		    {
	      case 3:   feedback('T','0','3'); break;
	      case 4:   feedback('S','0','4'); break;
	      case 5:   feedback('S','0','5'); break;
	      case 6:   feedback('S','0','6'); break;
	      case 7:   feedback('S','0','7'); break;
		    }
	    }

	    wait1Msec(100);

	    nxtDisplayString(6, "Happy Level: "+happy);
	    switch(happy)
		  {
		    case 10:  feedback('T','0','7'); break;
	      case 20:   feedback('S','0','1'); wait1Msec(100); feedback('V','1','7'); happy -= 5; break;
	      case 70:   feedback('S','0','9'); happy += 5;   break;
	      case 100:   feedback('T','0','5'); wait1Msec(100); feedback('S','0','7'); happy += 10; break;
	      case 200:   feedback('T','0','4'); wait1Msec(100); feedback('S','1','0'); happy += 10;  break;
	      case 500: feedback('T','0','3'); break;
		  }

    //Check for feeding - add hunger index or complain about too full
	    string foodType;
	    bool talkAboutFood = false;

	    switch (SensorValue[feed])
	    {
	      case BLUECOLOR:     foodType = "Blueberries";   hunger+=5; talkAboutFood = true;  break;
	      case GREENCOLOR:    foodType = "Bamboo leafs";   hunger+=7; talkAboutFood = true;  break;
	      case YELLOWCOLOR:   foodType = "Curry Beef";  hunger+=10; talkAboutFood = true;  break;
	      case REDCOLOR:      foodType = "Vampire Blood";    hunger+=20; talkAboutFood = true;   break;
	    }

	    nxtDisplayString(7, "Hunger Level: "+hunger);
	    if(talkAboutFood == true){
	      nxtDisplayString(5, foodType);
	      if(random(3)==0) { feedback('T','0','6'); wait1Msec(50); }
	    }
  }
  return;
}

//The move function
void movelegs(int leftMagitude, int rightMagitude, int time){
    motor[leftM]=leftMagitude;
    motor[rightM]=rightMagitude;
    wait1Msec(time);
}

//Moves head to a predefined angle.
void movehead(int headangle){
  if (nMotorEncoder[headM] < headangle) //When head angle is less than desired angle
  {
    while (nMotorEncoder[headM] < headangle)
      motor[headM] = 30;
    motor[headM] = 0;
  }
  else if (nMotorEncoder[headM] > headangle) //When head angle is greater than desired angle
  {
    while (nMotorEncoder[headM] < headangle)
      motor[headM] = -30;
    motor[headM] = 0;
  }
}

//Modified from RobotC sample code
void checkBTLinkConnected()
{
	if (nBTCurrentStreamIndex >= 0)
	  return;  // An existing Bluetooth connection is present.

	// Not connected. Audible notification and LCD error display
	eraseDisplay();
	nxtDisplayCenteredTextLine(1, "ERROR");
	nxtDisplayCenteredTextLine(3, "Connect Android app");
	nxtDisplayCenteredTextLine(4, "then try again");
	wait1Msec(3000);
	StopAllTasks();
}

//Modified from RobotC sample code
void feedback(char type, char one, char two)
{
	const int kSendSize = 3;
	static ubyte BytesToSend[kSendSize];

	BytesToSend[0] = type;
	BytesToSend[1] = one;
	BytesToSend[2] = two;

	nxtWriteRawBluetooth(BytesToSend, sizeof(BytesToSend));
}

void die(string diereason)
{
    death=true;
    death_reason=diereason;
    //Stop all movemenmts!
    movelegs(0,0,30000);
    movehead(HEAD_DEAD);
}

void funeral()
{
    movehead(HEAD_DEAD);
    feedback('V','2','0');
    wait1Msec(100); //a break is needed so Android does not receive the message together.
    feedback('S','0','8');
    wait1Msec(100);
    feedback('T','0','5');
    wait1Msec(100);
    feedback('V','2','5');
    //PlaySoundFile("Startup.rso");
    //wait1Msec(80);
    //PlaySoundFile("Startup.rso");
    //wait1Msec(80);
    //for(int i=0; i<15; i++) PlaySoundFile("Woops.rso");
    eraseDisplay();
    nxtDisplayCenteredTextLine(1,"===GAME OVER===");
    nxtDisplayCenteredTextLine(2,death_reason);
    wait1Msec(300);
    nxtDisplayBigStringAt(25, 25, "X__X");
    while(true);
}
